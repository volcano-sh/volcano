name: Close Issues

on:
  pull_request:
    types: [closed]
    branches: [master]  
  workflow_dispatch:
    inputs:
      issue_numbers:
        description: 'Comma-separated list of issue numbers (e.g., 123,456,789)'
        required: true
        type: string
      reason:
        description: 'Reason for closing'
        required: false
        default: 'Fixed in recent PR'
        type: string

jobs:
  close-issues-auto:
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    name: Close linked issues automatically
    timeout-minutes: 10
    permissions:
      issues: write
      pull-requests: read
    steps:
      - name: Close linked issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { pull_request } = context.payload;
            const textToSearch = [pull_request.title, pull_request.body].join('\n');
            
            // CRITICAL FIX: Added word boundaries to prevent partial matches
            const issueRegex = /\b(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s*:?\s*#(\d+)\b/gi;
            const issueNumbers = [];
            
            let match;
            while ((match = issueRegex.exec(textToSearch)) !== null) {
                issueNumbers.push(parseInt(match[1]));
            }
            
            const uniqueIssues = [...new Set(issueNumbers)].filter(num => num > 0);
            
            if (uniqueIssues.length === 0) {
                console.log('No linked issues found in PR body or title');
                return;
            }
            
            for (const issueNumber of uniqueIssues) {
                try {
                    // SECURITY: Verify issue belongs to current repo
                    const { data: issue } = await github.rest.issues.get({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber
                    });
                    
                    // Skip if issue is external
                    if (!issue.html_url.includes(`/${context.repo.owner}/${context.repo.repo}/`)) {
                        console.log(`Skipping external issue #${issueNumber}`);
                        continue;
                    }
                    
                    if (issue.state === 'open') {
                        await github.rest.issues.update({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: issueNumber,
                            state: 'closed'
                        });
                        
                        await github.rest.issues.createComment({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: issueNumber,
                            body: `Automatically closed by PR #${pull_request.number}`
                        });
                        
                        console.log(`Closed issue #${issueNumber}`);
                    } else {
                        console.log(`Issue #${issueNumber} is already closed`);
                    }
                } catch (error) {
                    // CRITICAL: Use proper error logging
                    core.warning(`Skipping issue #${issueNumber}: ${error.message}`);
                }
            }

  close-issues-manual:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    name: Close specified issues manually
    timeout-minutes: 10
    permissions:
      issues: write
    steps:
      - name: Close specified issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // CRITICAL FIX: Use context to avoid injection vulnerabilities
            const issueNumbers = context.payload.inputs.issue_numbers
                .split(',')
                .map(num => parseInt(num.trim().replace(/\D/g, '')))  // Sanitize input
                .filter(num => !isNaN(num) && num > 0);
            
            const reason = context.payload.inputs.reason || 'Closed manually';
            
            if (issueNumbers.length === 0) {
                core.setFailed('No valid issue numbers provided');
                return;
            }
            
            for (const issueNumber of issueNumbers) {
                try {
                    const { data: issue } = await github.rest.issues.get({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber
                    });
                    
                    if (issue.state === 'open') {
                        await github.rest.issues.update({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: issueNumber,
                            state: 'closed'
                        });
                        
                        await github.rest.issues.createComment({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: issueNumber,
                            body: `Issue closed: ${reason}`
                        });
                        
                        console.log(`Closed issue #${issueNumber}`);
                    } else {
                        console.log(`Issue #${issueNumber} is already closed`);
                    }
                } catch (error) {
                    core.warning(`Skipping issue #${issueNumber}: ${error.message}`);
                }
            }